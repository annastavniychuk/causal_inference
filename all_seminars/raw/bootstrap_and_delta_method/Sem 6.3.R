{
  library(ggplot2)
  library(boot)
  library(svMisc)
}

################################## ГЕНЕРИРУЕМ ДАННЫЕ ##################################
# Оценим зарплатное уравнение, согласно которому з/п изменяется с возрастом
set.seed(123)
age <- sample(18:40, 200, replace = TRUE) # 200 человек
eps <- rnorm(200, 0, 300) # случайный шок
y <- 4000 + 200 * age - 3 * (age^2) + eps #истинная зависимость заработка от возраста
data <- data.frame(y = y, age = age, age2 = age^2)

# специально сделали большую дисперсию у шока
plot(y ~ age)
qplot(data = data, x = age, y = y)
qplot(x = age, y = y)
qplot(age, y)



################################## ОЦЕНКА МНК ##################################
model1 <- lm(y ~ age + I(age^2))
summary(model1)
tipping <- - coef(model1)[2] / (2 * coef(model1)[3])
tipping #после какого возраста заработок падает
#проблема: как посчитать доверительный интервал для "точки перелома"?



################################## BOOTSTRAP -- РУЧКАМИ ##################################
B <- 1000 # количество псевдовыборок, которое будем использовать
tip <- NULL # цикл нужно с чего-то начать, поэтому создаём пустой вектор, куда попадут все оценки
tip

for (i in 1:1000) { # для каждой псевдовыборки
  progress(i, 1000, progress.bar = TRUE) # для progress bar
  boot_sample <- data[sample(seq(1:nrow(data)), replace = TRUE),] # размер бутстраповской выборки совпадает с размером исходной выборки
  boot_model <- lm(y ~ age + I(age^2), data = boot_sample)
  tip <- append(tip, - coef(boot_model)[2] / (2 * coef(boot_model)[3]))
}

c(quantile(tip, 0.025), quantile(tip, 0.975)) # границы доверительного интервала



################################## BOOTSTRAP -- АВТОМАТИЗИРОВАННЫЙ ##################################
# вспомогательная функция - что именно считаем: точку вершины параболы
bs <- function(data, indices, formula) {
  # здесь надо обязательно два аргумента
  # 1) данные, которые будут сэмплироваться (data)
  # 2) индексы наблюдений после сэмплирования (indices) (boot сам на каждой итерации будет подставлять сюда значения)
  
  boot_sample <- data[indices,] # ВАЖНАЯ СТРОКА -- она нужна, чтобы boot создал псевдовыборку 
  fit <- lm(formula, data = boot_sample)
  return(- fit$coef[2] / (2 * fit$coef[3])) # должна возвращать статистику, которую мы бутстрапируем
  # можно возвращать одновременно несколько статистик, если объединить их в list
}


results <- boot(
  data = data, 
  statistic = bs, # наша функция
  R = B, # оставим то же количество итераций
  formula = y ~ age + I(age^2)) # см. аргумент функции bs

CI_auto <- boot.ci(results) # это объект с доверительными интервалами
hist(results$t) # распределение оценок по бутстрапу
qplot(results$t)
CI_auto # 4 варианта пострения доверительных интервалов
# ручками мы построили percentile

# тут подробно про каждый из видов доверительных интервалов и когда какой уместнее использовать:
# https://blog.methodsconsultants.com/posts/understanding-bootstrap-confidence-interval-output-from-the-r-boot-package/



################################## DELTA-METHOD ##################################
## два варианта:
# 1) более автоматизированный через пакет car
library(car)
help(deltaMethod)
model1 <- lm(y ~ age + age2, data = data)
summary(model1)
deltaMethod(model1,"- age / (2 * (age2))")

# 2) менее автоматизированный, но более гибкий через пакет msm
library(msm)
deltamethod(g ~ - x1 / (2 * x2),
  # здесь руками задаются параметры распределения случайного вектора, от которого зависит функция g 
  mean = coef(model1)[-1],
  cov = vcov(model1)[-1, -1])



